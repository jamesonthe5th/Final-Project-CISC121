Decomposition of the merge sort:
Start with getting input values from user interface
Store the initial input
Recursively split the arrays in half until length 1 or 0. (the dividing part)
Begin the merge step comparing two halves of original array with index values i and j whichever is lesser is appended to the sorted full array
Continue until no more merges are made then either append leftover elements and return or return.

Pattern recognition of the merge sort:
the pattern is quite simple first it begins with split, split, split until length 1 or 0 base case, then it switches to merge merge merge until fully merged. 
comparision pattern also made comparion list1[0] with list2[0] to find lesser. 

Abstraction of merge sort:
What were going to hide:
pointer index manipulation
temporary lists uses
recursive function call stack

What were going to show:
current lists or sublists
each split step
each merge
comparisions
newly formed list after each merge
final sorted list

Algorithm design for merge sort:
Input:
box with commas for separations of integers eg our list
Output:
The gradio GUI of the merges the split steps the comparisions and the newly formed list and final list
Flow chart:
[User enters list through GUI]
[Call Merge_sort algorithm with snapshots]
[Base case len(list0) == 1 or 0]
yes [return list]
no [split into left and right]
[Compare values using pointers]
[append to final list]
[return]





